# 变量命名的规则：

​	变量名可以有数字、字母、_但是不能以数字开头

​	变量名也不能是关键字/保留字

​	变量名还严格区分大小写

​	变量名最好遵守小驼峰命名法



# 数据类型：

## 	基本数据类型

​	Numbers、String、Boolean、Undefined（声明未赋值）、Null

## 	复杂数据类型

​	Object	

​	用typeof判断null会得到object但实际上这是一个单独的数据类型

​	**一个变量刚声明未赋值就是undefined，null也是必须要赋值才会有null**

## 	谷歌浏览器控制台变量类型对应的颜色

​	黑色=>string

​	蓝色=>numbers、boolean

​	灰色=>**undefined、null区别？需要增强认知**

# 数据类型转换：

## 	字符串转换：

​		变量.toString()（无法用undefined.toString()/null.toString()）

​		**String(变量)**

## 	数值转换：

​		**Number(变量)**

​		parseInt(变量) 取整

​		parseFloat(变量) 转为浮点数

​		转换数值类型时boolean会转换为1或0，undefined和null以及string类型会被转换为NaN（not a numbers）

​		**转换为数值类型的时候如果第一个为数字则会转换到其他类型结束，但如果第一个是其他类型则会直接返回NaN**

​		NaN和任何值都不相等包括本身，所以单独有个函数 **isNaN()**来判断是否为NaN类型，undefined也会被isNaN判断为正确

​		进行加减乘除运算的过程也会进行数值类型转换

## 	布尔类型转换

​		**Boolean()**

​		字符串类型的话只要有值则算作true无值算false

​		**a+=b => a = a + b 其他逻辑运算符和=连接也是这样**

运算符的优先级

![image-20220907141137408](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220907141137408.png)

三元就是 表达式? 赋值A ：赋值B

# 条件及循环：

```
switch(n)
{
    case 1:
        执行代码块 1
        break;
    case 2:
        执行代码块 2
        break;
    default:
        与 case 1 和 case 2 不同时执行的代码
}
```

```
for (var i=0;i<cars.length;i++)
{ 
    document.write(cars[i] + "<br>");
}
array.forEach(funcName,)
```

```
var person={fname:"Bill",lname:"Gates",age:56}; 
	for (x in person){
		txt=txt + person[x];
	}
```

# 函数声明及调用的方式：

```js

1.function name ()
{
    
}
name();
2.var name = function(){
    
}
name();
3.(function(){
    
})();

```

# 变量提升及函数预加载

变量提升的意思是，如果

```
console.log(num);
var num = 10;
则此处的 num会提前到console.log前声明，但是赋值不会提前，因此console.log打印的是undefined
```

函数预加载，是整个函数包括函数体提升不仅仅是声明

```
fn();
function fn()
{
console.log(300)
}
此处的函数虽然在定义前调用，但是此处的函数的定义是可以提前的，因此函数的使用也是正常的，但是函数的预加载不能以变量形式声明，不然就会跟变量提升冲突导致变量并没有装载函数而是报错 is not a function
```

# js执行过程

预编译(语法检查)->执行

js错误类型

​	编译错误 全部js代码不会执行

​	执行错误 错误之前代码可以执行，之后代码不会执行，**继续往下找另一个script标签**

​	执行代码前**先进行变量提升后进行函数预加载**



# js变量使用的选择

先从调用的函数作用域查找，如果没有再往上一级查找

```
var obj = {"name":"func","save":function(){console.log(1)}};
obj.save();
实际上是调用save方法
```

对象的调用也可以用obj.['save']

属性名的双引号可以不加

# 构造函数

```
var a = function(){}
/
function a (){}
var b = new a();//这种调用就是把a方法当做构造函数来调用
```

# this

构造函数：this 其实就是当前作用域实例化后的对象

非构造函数：如果不实例化的话，函数里的this就指向一个window对象（js运行在浏览器时，此处的	this就是window对象/全局对象）

可以用**obj.name**赋值也可以构造函数里**this.name**赋值

tips：

​	如果this处在某个实例中则指代这个实例，如果不存在某个实例中则应当指代window对象	